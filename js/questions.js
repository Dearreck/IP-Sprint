// js/questions.js
// ==================================================
// Módulo Generador de Preguntas para IP Sprint
// CORREGIDO: Error 'Assignment to constant variable' en generateIdentifyIpTypeQuestion.
// ==================================================

// --- Importaciones de Módulos ---
import {
    getRandomInt, generateRandomIp, generateRandomPrivateIp, getIpInfo, shuffleArray,
    generateClassRangeTableHTML, generatePrivateRangeTableHTML,
    getIpPortions, generatePortionExplanationHTML, generateSpecialAddressExplanationHTML,
    calculateNetworkAddress, calculateBroadcastAddress, calculateWildcardMask,
    generateRandomSubnetMask, generateWildcardExplanationHTML,
    getMaskPrefixLength, calculateUsableHosts, calculateNumberOfSubnets, generateSubnettingExplanationHTML,
    formatNumber,
    getFirstUsableHost, getLastUsableHost, generateIpTypeExplanationHTML,
    generateBitsForSubnetsExplanationHTML, generateBitsForHostsExplanationHTML,
    prefixToMaskString, generateMaskForHostsExplanationHTML
} from './utils.js';

import { getTranslation } from './i18n.js';

// --- Generadores de Preguntas (Nivel Entry) ---
function generateClassQuestion() { try { const ip = generateRandomIp(); const info = getIpInfo(ip); if (info.class === 'N/A') return generateClassQuestion(); const question = { key: 'question_given_ip_what_class', replacements: { ip: `<strong>${ip}</strong>` } }; const options = ['A', 'B', 'C', 'D', 'E']; const correct = info.class; const explanationInfo = { generatorName: 'generateClassRangeTableHTML', args: [correct] }; return { question, options, correctAnswer: correct, explanation: explanationInfo }; } catch (error) { console.error("Error en generateClassQuestion:", error); return null; } }
function generateTypeQuestion() { try { let ip, info, attempts = 0; let forcePrivate = Math.random() < 0.4; ip = forcePrivate ? generateRandomPrivateIp() : generateRandomIp(); info = getIpInfo(ip); while ((info.typeKey === 'unknown' || info.typeKey === 'loopback' || info.typeKey === 'apipa' || info.typeKey === 'limited_broadcast') && attempts < 50) { ip = generateRandomIp(); info = getIpInfo(ip); attempts++; } if (info.typeKey !== 'public' && info.typeKey !== 'private') { ip = '8.8.8.8'; info = getIpInfo(ip); } const question = { key: 'question_given_ip_what_type', replacements: { ip: `<strong>${ip}</strong>` } }; const options = ['option_public', 'option_private']; const correct = `option_${info.typeKey}`; const explanationInfo = { generatorName: 'generatePrivateRangeTableHTML', args: [ip] }; return { question, options, correctAnswer: correct, explanation: explanationInfo }; } catch (error) { console.error("Error en generateTypeQuestion:", error); return null; } }
function generateDefaultMaskQuestion() { try { let ip, info, attempts = 0; do { ip = generateRandomIp(); info = getIpInfo(ip); attempts++; } while ((info.class !== 'A' && info.class !== 'B' && info.class !== 'C' || info.typeKey === 'loopback') && attempts < 100); if (attempts >= 100) { ip = '192.168.1.1'; info = getIpInfo(ip); } const question = { key: 'question_given_ip_what_mask', replacements: { ip: `<strong>${ip}</strong>`, class: info.class } }; const options = ['255.0.0.0', '255.255.0.0', '255.255.255.0']; const correct = info.defaultMask; const explanationInfo = { generatorName: 'generateClassRangeTableHTML', args: [info.class] }; const finalCorrectAnswer = options.includes(correct) ? correct : options[0]; return { question, options, correctAnswer: finalCorrectAnswer, explanation: explanationInfo }; } catch (error) { console.error("Error en generateDefaultMaskQuestion:", error); return null; } }
function generateSelectClassQuestion() { try{ const targetClasses = ['A', 'B', 'C']; const targetClass = targetClasses[getRandomInt(0, targetClasses.length - 1)]; const question = { key: 'question_select_ip_for_class', replacements: { targetClass: `<strong>${targetClass}</strong>` } }; let correctIp = ''; let incorrectIps = []; let attempts = 0; let ipSet = new Set(); while (!correctIp && attempts < 100) { let ip = generateRandomIp(); let info = getIpInfo(ip); if (info.class === targetClass && info.typeKey !== 'loopback') { correctIp = ip; ipSet.add(ip); } attempts++; } if (!correctIp) { if(targetClass === 'A') correctIp = '10.1.1.1'; else if(targetClass === 'B') correctIp = '172.16.1.1'; else correctIp = '192.168.1.1'; ipSet.add(correctIp); } attempts = 0; while (incorrectIps.length < 3 && attempts < 300) { let ip = generateRandomIp(); let info = getIpInfo(ip); if (info.class !== targetClass && info.class !== 'N/A' && info.typeKey !== 'loopback' && !ipSet.has(ip)) { incorrectIps.push(ip); ipSet.add(ip); } attempts++; } if(incorrectIps.length < 3) { const fallbacks = ['8.8.8.8', '224.0.0.5', '169.254.1.1', '150.150.1.1', '200.200.1.1', '126.1.1.1', '191.1.1.1']; for (const fb of fallbacks) { if (incorrectIps.length < 3 && !ipSet.has(fb) && getIpInfo(fb).class !== targetClass) { incorrectIps.push(fb); ipSet.add(fb); } } } incorrectIps = incorrectIps.slice(0, 3); const options = [correctIp, ...incorrectIps]; shuffleArray(options); const correct = correctIp; const explanationInfo = { baseTextKey: 'explanation_select_ip_for_class', replacements: { targetClass: targetClass, correctIp: correct }, generatorName: 'generateClassRangeTableHTML', args: [targetClass] }; return { question, options, correctAnswer: correct, explanation: explanationInfo }; } catch (error) { console.error("Error en generateSelectClassQuestion:", error); return null; } }
function generateSelectPrivateIpQuestion() { try { const question = { key: 'question_select_private_ip' }; let correctIp = generateRandomPrivateIp(); let incorrectIps = []; let attempts = 0; let ipSet = new Set([correctIp]); while (incorrectIps.length < 3 && attempts < 300) { let ip = generateRandomIp(); let info = getIpInfo(ip); if (info.typeKey === 'public' && !ipSet.has(ip)) { incorrectIps.push(ip); ipSet.add(ip); } attempts++; } if(incorrectIps.length < 3) { const fallbacks = ['8.8.8.8', '1.1.1.1', '203.0.113.1', '198.51.100.1', '172.15.1.1', '192.169.1.1']; for (const fb of fallbacks) { if (incorrectIps.length < 3 && !ipSet.has(fb)) { incorrectIps.push(fb); ipSet.add(fb); } } } incorrectIps = incorrectIps.slice(0, 3); const options = [correctIp, ...incorrectIps]; shuffleArray(options); const correct = correctIp; const explanationInfo = { generatorName: 'generatePrivateRangeTableHTML', args: [correct] }; return { question, options, correctAnswer: correct, explanation: explanationInfo }; } catch (error) { console.error("Error en generateSelectPrivateIpQuestion:", error); return null; } }
function generateSelectIpByDefaultMaskQuestion() { try { const targetMasks = ['255.0.0.0', '255.255.0.0', '255.255.255.0']; const targetMask = targetMasks[getRandomInt(0, targetMasks.length - 1)]; const question = { key: 'question_select_ip_for_mask', replacements: { targetMask: `<strong>${targetMask}</strong>` } }; let correctIp = ''; let incorrectIps = []; let attempts = 0; let ipSet = new Set(); while (!correctIp && attempts < 100) { let ip = generateRandomIp(); let info = getIpInfo(ip); if (info.defaultMask === targetMask && info.typeKey !== 'loopback') { correctIp = ip; ipSet.add(ip); } attempts++; } if (!correctIp) { if(targetMask === '255.0.0.0') correctIp = '10.1.1.1'; else if(targetMask === '255.255.0.0') correctIp = '172.16.1.1'; else correctIp = '192.168.1.1'; ipSet.add(correctIp); } attempts = 0; while (incorrectIps.length < 3 && attempts < 300) { let ip = generateRandomIp(); let info = getIpInfo(ip); if (info.defaultMask !== 'N/A' && info.defaultMask !== targetMask && info.typeKey !== 'loopback' && !ipSet.has(ip)) { incorrectIps.push(ip); ipSet.add(ip); } attempts++; } if(incorrectIps.length < 3) { const fallbacks = ['8.8.8.8', '224.0.0.1', '169.254.1.1', '172.30.1.1', '192.168.5.5', '126.1.1.1', '191.1.1.1']; for (const fb of fallbacks) { let fbInfo = getIpInfo(fb); if (incorrectIps.length < 3 && !ipSet.has(fb) && fbInfo.defaultMask !== targetMask && fbInfo.defaultMask !== 'N/A') { incorrectIps.push(fb); ipSet.add(fb); } } } incorrectIps = incorrectIps.slice(0, 3); const options = [correctIp, ...incorrectIps]; shuffleArray(options); const correct = correctIp; const correctClass = getIpInfo(correct).class; const explanationInfo = { baseTextKey: 'explanation_select_ip_for_mask', replacements: { class: correctClass, mask: targetMask }, generatorName: 'generateClassRangeTableHTML', args: [correctClass] }; return { question, options, correctAnswer: correct, explanation: explanationInfo }; } catch (error) { console.error("Error en generateSelectIpByDefaultMaskQuestion:", error); return null; } }

// --- Generadores de Preguntas (Nivel Associate) ---
// ... (Sin cambios) ...
function generateClassAndTypeQuestion() { try { let ip, info, attempts = 0; do { ip = generateRandomIp(); info = getIpInfo(ip); attempts++; } while ((info.class !== 'A' && info.class !== 'B' && info.class !== 'C' || info.typeKey === 'loopback') && attempts < 100); if (attempts >= 100) { ip = Math.random() < 0.5 ? '172.20.1.1' : '10.10.10.10'; info = getIpInfo(ip); } const question = { key: 'question_given_ip_what_class_type', replacements: { ip: `<strong>${ip}</strong>` } }; const correctClass = info.class; const correctAnswerObject = { classKey: `option_class_${correctClass.toLowerCase()}`, typeKey: `option_${info.typeKey}` }; let options = []; options.push(correctAnswerObject); const possibleClassesLower = ['a', 'b', 'c'].filter(c => c !== correctClass.toLowerCase()); const possibleTypeKeys = ['option_public', 'option_private'].filter(k => k !== correctAnswerObject.typeKey); if (possibleTypeKeys.length > 0) { options.push({ classKey: `option_class_${correctClass.toLowerCase()}`, typeKey: possibleTypeKeys[0] }); } if (possibleClassesLower.length > 0) { options.push({ classKey: `option_class_${possibleClassesLower[0]}`, typeKey: correctAnswerObject.typeKey }); } if (possibleClassesLower.length > 0 && possibleTypeKeys.length > 0) { options.push({ classKey: `option_class_${possibleClassesLower[0]}`, typeKey: possibleTypeKeys[0] }); } let existingOptionsStr = new Set(options.map(o => `${o.classKey},${o.typeKey}`)); while (options.length < 4) { const randomClassKey = `option_class_${['a', 'b', 'c'][getRandomInt(0, 2)]}`; const randomTypeKey = ['option_public', 'option_private'][getRandomInt(0, 1)]; const potentialOption = { classKey: randomClassKey, typeKey: randomTypeKey }; const potentialOptionStr = `${potentialOption.classKey},${potentialOption.typeKey}`; if (!existingOptionsStr.has(potentialOptionStr)) { options.push(potentialOption); existingOptionsStr.add(potentialOptionStr); } } options = options.slice(0, 4); shuffleArray(options); const explanationInfo = { generators: [ { generatorName: 'generateClassRangeTableHTML', args: [correctClass] }, { generatorName: 'generatePrivateRangeTableHTML', args: [ip] } ], separator: '<hr style="margin: 10px 0;">' }; return { question, options, correctAnswer: correctAnswerObject, explanation: explanationInfo }; } catch (error) { console.error("Error en generateClassAndTypeQuestion:", error); return null; } }
function generateClassAndDefaultMaskQuestion() { try { let ip, info, attempts = 0; do { ip = generateRandomIp(); info = getIpInfo(ip); attempts++; } while ((info.class !== 'A' && info.class !== 'B' && info.class !== 'C' || info.typeKey === 'loopback') && attempts < 100); if (attempts >= 100) { ip = '172.16.50.50'; info = getIpInfo(ip); } const question = { key: 'question_given_ip_what_class_mask', replacements: { ip: `<strong>${ip}</strong>` } }; const correctClass = info.class; const correctMask = info.defaultMask; const correctAnswerObject = { classKey: `option_class_${correctClass.toLowerCase()}`, maskValue: correctMask }; let options = []; options.push(correctAnswerObject); const possibleClassesLower = ['a', 'b', 'c'].filter(c => c !== correctClass.toLowerCase()); const possibleMasks = ['255.0.0.0', '255.255.0.0', '255.255.255.0'].filter(m => m !== correctMask); if (possibleMasks.length > 0) { options.push({ classKey: `option_class_${correctClass.toLowerCase()}`, maskValue: possibleMasks[0] }); } if (possibleClassesLower.length > 0) { options.push({ classKey: `option_class_${possibleClassesLower[0]}`, maskValue: correctMask }); } if (possibleClassesLower.length > 0) { let incorrectMaskForIncorrectClass = '255.255.255.255'; if (possibleClassesLower[0] === 'a' && possibleMasks.includes('255.0.0.0')) incorrectMaskForIncorrectClass = '255.0.0.0'; else if (possibleClassesLower[0] === 'b' && possibleMasks.includes('255.255.0.0')) incorrectMaskForIncorrectClass = '255.255.0.0'; else if (possibleClassesLower[0] === 'c' && possibleMasks.includes('255.255.255.0')) incorrectMaskForIncorrectClass = '255.255.255.0'; else if (possibleMasks.length > 0) incorrectMaskForIncorrectClass = possibleMasks[0]; const incorrectCombination = { classKey: `option_class_${possibleClassesLower[0]}`, maskValue: incorrectMaskForIncorrectClass }; if (!options.some(o => o.classKey === incorrectCombination.classKey && o.maskValue === incorrectCombination.maskValue)) { options.push(incorrectCombination); } } let existingOptionsStr = new Set(options.map(o => `${o.classKey},${o.maskValue}`)); while (options.length < 4) { const randomClassKey = `option_class_${['a', 'b', 'c'][getRandomInt(0, 2)]}`; const randomMask = ['255.0.0.0', '255.255.0.0', '255.255.255.0'][getRandomInt(0, 2)]; const potentialOption = { classKey: randomClassKey, maskValue: randomMask }; const potentialOptionStr = `${potentialOption.classKey},${potentialOption.maskValue}`; if (!existingOptionsStr.has(potentialOptionStr)) { options.push(potentialOption); existingOptionsStr.add(potentialOptionStr); } } options = options.slice(0, 4); shuffleArray(options); const explanationInfo = { generatorName: 'generateClassRangeTableHTML', args: [correctClass] }; return { question, options, correctAnswer: correctAnswerObject, explanation: explanationInfo }; } catch (error) { console.error("Error en generateClassAndDefaultMaskQuestion:", error); return null; } }
function generateClassAndNetworkPortionQuestion() { try { let ip, info, portions, attempts = 0; do { ip = generateRandomIp(); info = getIpInfo(ip); if (info.class === 'A' || info.class === 'B' || info.class === 'C') { portions = getIpPortions(ip, info.defaultMask); } else { portions = null; } attempts++; } while (!portions && attempts < 100); if (!portions) { ip = '192.168.1.100'; info = getIpInfo(ip); portions = getIpPortions(ip, info.defaultMask); if (!portions) throw new Error("Fallback IP falló"); } const question = { key: 'question_given_ip_what_class_net_portion', replacements: { ip: `<strong>${ip}</strong>` } }; const correctClass = info.class; const correctNetworkPortion = portions.networkPortion; if (!correctNetworkPortion && correctNetworkPortion !== "") throw new Error(`No se pudo obtener networkPortion para ${ip}`); const correctAnswerObject = { classKey: `option_class_${correctClass.toLowerCase()}`, portionKey: 'option_network_portion', portionValue: correctNetworkPortion || 'None' }; let options = []; options.push(correctAnswerObject); const possibleClassesLower = ['a', 'b', 'c'].filter(c => c !== correctClass.toLowerCase()); let randomIpForPortion, randomInfoForPortion, incorrectNetworkPortion = null, portionAttempts = 0; do { randomIpForPortion = generateRandomIp(); randomInfoForPortion = getIpInfo(randomIpForPortion); if (randomInfoForPortion.defaultMask !== 'N/A') { incorrectNetworkPortion = getIpPortions(randomIpForPortion, randomInfoForPortion.defaultMask)?.networkPortion; } portionAttempts++; } while ((!incorrectNetworkPortion || incorrectNetworkPortion === correctNetworkPortion) && portionAttempts < 50); if (incorrectNetworkPortion && incorrectNetworkPortion !== correctNetworkPortion) { options.push({ classKey: `option_class_${correctClass.toLowerCase()}`, portionKey: 'option_network_portion', portionValue: incorrectNetworkPortion }); } else { let fallbackPortion = (correctClass !== 'A') ? `${getRandomInt(1,126)}` : `${getRandomInt(128,191)}.${getRandomInt(0,255)}`; options.push({ classKey: `option_class_${correctClass.toLowerCase()}`, portionKey: 'option_network_portion', portionValue: fallbackPortion }); } if (possibleClassesLower.length > 0) { options.push({ classKey: `option_class_${possibleClassesLower[0]}`, portionKey: 'option_network_portion', portionValue: correctNetworkPortion || 'None' }); } if (possibleClassesLower.length > 0 && incorrectNetworkPortion && incorrectNetworkPortion !== correctNetworkPortion) { options.push({ classKey: `option_class_${possibleClassesLower[0]}`, portionKey: 'option_network_portion', portionValue: incorrectNetworkPortion }); } let existingOptionsStr = new Set(options.map(o => `${o.classKey},${o.portionKey},${o.portionValue}`)); while (options.length < 4) { const randomClassKey = `option_class_${['a', 'b', 'c'][getRandomInt(0, 2)]}`; let randomPortion = ''; if (randomClassKey === 'option_class_a') randomPortion = `${getRandomInt(1, 126)}`; else if (randomClassKey === 'option_class_b') randomPortion = `${getRandomInt(128, 191)}.${getRandomInt(0, 255)}`; else randomPortion = `${getRandomInt(192, 223)}.${getRandomInt(0, 255)}.${getRandomInt(0, 255)}`; const potentialOption = { classKey: randomClassKey, portionKey: 'option_network_portion', portionValue: randomPortion }; const potentialOptionStr = `${potentialOption.classKey},${potentialOption.portionKey},${potentialOption.portionValue}`; if (!existingOptionsStr.has(potentialOptionStr)) { options.push(potentialOption); existingOptionsStr.add(potentialOptionStr); } } options = options.slice(0, 4); shuffleArray(options); const wildcardMask = calculateWildcardMask(info.defaultMask); const networkAddr = calculateNetworkAddress(ip, info.defaultMask); const broadcastAddr = calculateBroadcastAddress(networkAddr, wildcardMask); const explanationInfo = { generatorName: 'generatePortionExplanationHTML', args: [ip, info.defaultMask, wildcardMask, networkAddr, broadcastAddr] }; return { question, options, correctAnswer: correctAnswerObject, explanation: explanationInfo }; } catch (error) { console.error("Error en generateClassAndNetworkPortionQuestion:", error); return null; } }
function generateClassAndHostPortionQuestion() { try { let ip, info, portions, attempts = 0; do { ip = generateRandomIp(); info = getIpInfo(ip); if (info.class === 'A' || info.class === 'B' || info.class === 'C') { portions = getIpPortions(ip, info.defaultMask); } else { portions = null; } attempts++; } while (!portions && attempts < 100); if (!portions) { ip = '172.16.10.20'; info = getIpInfo(ip); portions = getIpPortions(ip, info.defaultMask); if (!portions) throw new Error("Fallback IP falló"); } const question = { key: 'question_given_ip_what_class_host_portion', replacements: { ip: `<strong>${ip}</strong>` } }; const correctClass = info.class; const correctHostPortion = portions.hostPortion; if (!correctHostPortion && correctHostPortion !== "") throw new Error(`No se pudo obtener hostPortion para ${ip}`); const correctAnswerObject = { classKey: `option_class_${correctClass.toLowerCase()}`, portionKey: 'option_host_portion', portionValue: correctHostPortion || 'None' }; let options = []; options.push(correctAnswerObject); const possibleClassesLower = ['a', 'b', 'c'].filter(c => c !== correctClass.toLowerCase()); let randomIpForPortion, randomInfoForPortion, incorrectHostPortion = null, portionAttempts = 0; do { randomIpForPortion = generateRandomIp(); randomInfoForPortion = getIpInfo(randomIpForPortion); if (randomInfoForPortion.defaultMask !== 'N/A') { incorrectHostPortion = getIpPortions(randomIpForPortion, randomInfoForPortion.defaultMask)?.hostPortion; } portionAttempts++; } while ((!incorrectHostPortion || incorrectHostPortion === correctHostPortion) && portionAttempts < 50); if (incorrectHostPortion && incorrectHostPortion !== correctHostPortion) { options.push({ classKey: `option_class_${correctClass.toLowerCase()}`, portionKey: 'option_host_portion', portionValue: incorrectHostPortion }); } else { let fallbackPortion = (correctClass !== 'C') ? `${getRandomInt(1,254)}` : `${getRandomInt(0,255)}.${getRandomInt(1,254)}`; options.push({ classKey: `option_class_${correctClass.toLowerCase()}`, portionKey: 'option_host_portion', portionValue: fallbackPortion }); } if (possibleClassesLower.length > 0) { options.push({ classKey: `option_class_${possibleClassesLower[0]}`, portionKey: 'option_host_portion', portionValue: correctHostPortion || 'None' }); } if (possibleClassesLower.length > 0 && incorrectHostPortion && incorrectHostPortion !== correctHostPortion) { options.push({ classKey: `option_class_${possibleClassesLower[0]}`, portionKey: 'option_host_portion', portionValue: incorrectHostPortion }); } let existingOptionsStr = new Set(options.map(o => `${o.classKey},${o.portionKey},${o.portionValue}`)); while (options.length < 4) { const randomClassKey = `option_class_${['a', 'b', 'c'][getRandomInt(0, 2)]}`; let randomPortion = ''; if (randomClassKey === 'option_class_a') randomPortion = `${getRandomInt(0, 255)}.${getRandomInt(0, 255)}.${getRandomInt(1, 254)}`; else if (randomClassKey === 'option_class_b') randomPortion = `${getRandomInt(0, 255)}.${getRandomInt(1, 254)}`; else randomPortion = `${getRandomInt(1, 254)}`; const potentialOption = { classKey: randomClassKey, portionKey: 'option_host_portion', portionValue: randomPortion }; const potentialOptionStr = `${potentialOption.classKey},${potentialOption.portionKey},${potentialOption.portionValue}`; if (!existingOptionsStr.has(potentialOptionStr)) { options.push(potentialOption); existingOptionsStr.add(potentialOptionStr); } } options = options.slice(0, 4); shuffleArray(options); const wildcardMask = calculateWildcardMask(info.defaultMask); const networkAddr = calculateNetworkAddress(ip, info.defaultMask); const broadcastAddr = calculateBroadcastAddress(networkAddr, wildcardMask); const explanationInfo = { generatorName: 'generatePortionExplanationHTML', args: [ip, info.defaultMask, wildcardMask, networkAddr, broadcastAddr] }; return { question, options, correctAnswer: correctAnswerObject, explanation: explanationInfo }; } catch (error) { console.error("Error en generateClassAndHostPortionQuestion:", error); return null; } }
function generateRfc1918Question() { try { const rfcLink = 'https://datatracker.ietf.org/doc/html/rfc1918'; const rfc1918Blocks = [ { cidr: '/8', range: '10.0.0.0 - 10.255.255.255', blockStart: '10.0.0.0', class: 'A', blockId: '10.0.0.0/8' }, { cidr: '/12', range: '172.16.0.0 - 172.31.255.255', blockStart: '172.16.0.0', class: 'B', blockId: '172.16.0.0/12' }, { cidr: '/16', range: '192.168.0.0 - 192.168.255.255', blockStart: '192.168.0.0', class: 'C', blockId: '192.168.0.0/16' } ]; const otherCidrs = ['/10', '/20', '/24', '/28']; const possibleClasses = ['A', 'B', 'C']; const chosenBlock = rfc1918Blocks[getRandomInt(0, rfc1918Blocks.length - 1)]; let question = {}; let correctAnswer = ''; let options = []; let explanationInfo = {}; const questionType = getRandomInt(0, 2); const rfcLinkHTML = `<a href="${rfcLink}" target="_blank" rel="noopener noreferrer">RFC 1918</a>`; if (questionType === 0) { question = { key: 'question_rfc1918_cidr_from_block', replacements: { rfcLinkHTML: rfcLinkHTML, blockStart: `<strong>${chosenBlock.blockStart}</strong>` } }; correctAnswer = chosenBlock.cidr; options = [correctAnswer]; let incorrectOptions = otherCidrs.filter(c => c !== correctAnswer); shuffleArray(incorrectOptions); options.push(...incorrectOptions.slice(0, 3)); } else if (questionType === 1) { question = { key: 'question_rfc1918_range_from_cidr', replacements: { rfcLinkHTML: rfcLinkHTML, cidr: `<strong>${chosenBlock.cidr}</strong>` } }; correctAnswer = chosenBlock.range; options = [correctAnswer]; let incorrectOptions = rfc1918Blocks.filter(b => b.cidr !== chosenBlock.cidr).map(b => b.range); if (incorrectOptions.length < 3) { incorrectOptions.push('8.8.0.0 - 8.8.255.255'); } options.push(...incorrectOptions.slice(0, 3)); } else { const blockIdentifier = chosenBlock.blockId; question = { key: 'question_rfc1918_class_from_block', replacements: { rfcLinkHTML: rfcLinkHTML, blockIdentifier: `<strong>${blockIdentifier}</strong>` } }; correctAnswer = chosenBlock.class; options = [correctAnswer]; let incorrectOptions = possibleClasses.filter(c => c !== correctAnswer); options.push(...incorrectOptions); } shuffleArray(options); if (options.length > 4) options = options.slice(0, 4); if (!options.includes(correctAnswer)) { options.pop(); options.push(correctAnswer); shuffleArray(options); } explanationInfo = { generatorName: 'generatePrivateRangeTableHTML', args: [chosenBlock.blockStart] }; if (questionType === 2) { explanationInfo.baseTextKey = 'explanation_rfc1918_class_note'; explanationInfo.replacements = { blockId: `<strong>${chosenBlock.blockId}</strong>`, class: `<strong>${chosenBlock.class}</strong>` }; } return { question, options, correctAnswer, explanation: explanationInfo }; } catch (error) { console.error("Error en generateRfc1918Question:", error); return null; } }
function generateIdentifyNetworkPortionQuestion() { try { let ip, info, portions, attempts = 0; do { ip = generateRandomIp(); info = getIpInfo(ip); if (info.class === 'A' || info.class === 'B' || info.class === 'C') { portions = getIpPortions(ip, info.defaultMask); } else { portions = null; } attempts++; } while (!portions && attempts < 100); if (!portions) { ip = '192.168.10.50'; info = getIpInfo(ip); portions = getIpPortions(ip, info.defaultMask); if (!portions) throw new Error("Fallback IP falló"); } const question = { key: 'question_identify_network_portion', replacements: { ip: `<strong>${ip}</strong>`, mask: `<strong>${info.defaultMask}</strong>` } }; const correctAnswer = portions.networkPortion || getTranslation('option_none'); let options = new Set([correctAnswer]); if (portions.hostPortion && portions.hostPortion !== correctAnswer) { options.add(portions.hostPortion || getTranslation('option_none')); } let randomIpForPortion, randomInfoForPortion, incorrectNetworkPortion = null, incorrectHostPortion = null, portionAttempts = 0; do { randomIpForPortion = generateRandomIp(); randomInfoForPortion = getIpInfo(randomIpForPortion); if (randomInfoForPortion.defaultMask !== 'N/A') { incorrectNetworkPortion = getIpPortions(randomIpForPortion, randomInfoForPortion.defaultMask)?.networkPortion; incorrectHostPortion = getIpPortions(randomIpForPortion, randomInfoForPortion.defaultMask)?.hostPortion; } portionAttempts++; } while ((!incorrectNetworkPortion || incorrectNetworkPortion === correctAnswer) && portionAttempts < 50); if (incorrectNetworkPortion && incorrectNetworkPortion !== correctAnswer) { options.add(incorrectNetworkPortion); } if (incorrectHostPortion && incorrectHostPortion !== correctAnswer && !options.has(incorrectHostPortion)) { options.add(incorrectHostPortion || getTranslation('option_none')); } while (options.size < 4) { const randomClass = ['A', 'B', 'C'][getRandomInt(0, 2)]; let randomPortion = ''; if (randomClass === 'A') randomPortion = `${getRandomInt(1, 126)}`; else if (randomClass === 'B') randomPortion = `${getRandomInt(128, 191)}.${getRandomInt(0, 255)}`; else randomPortion = `${getRandomInt(192, 223)}.${getRandomInt(0, 255)}.${getRandomInt(0, 255)}`; if (randomPortion !== correctAnswer) { options.add(randomPortion); } } let optionsArray = Array.from(options); if (!optionsArray.includes(correctAnswer)) { optionsArray.pop(); optionsArray.push(correctAnswer); } optionsArray = optionsArray.slice(0, 4); shuffleArray(optionsArray); const wildcardMask = calculateWildcardMask(info.defaultMask); const networkAddr = calculateNetworkAddress(ip, info.defaultMask); const broadcastAddr = calculateBroadcastAddress(networkAddr, wildcardMask); const explanationInfo = { generatorName: 'generatePortionExplanationHTML', args: [ip, info.defaultMask, wildcardMask, networkAddr, broadcastAddr] }; return { question, options: optionsArray, correctAnswer, explanation: explanationInfo }; } catch (error) { console.error("Error en generateIdentifyNetworkPortionQuestion:", error); return null; } }
function generateIdentifyHostPortionQuestion() { try { let ip, info, portions, attempts = 0; do { ip = generateRandomIp(); info = getIpInfo(ip); if (info.class === 'A' || info.class === 'B' || info.class === 'C') { portions = getIpPortions(ip, info.defaultMask); } else { portions = null; } attempts++; } while (!portions && attempts < 100); if (!portions) { ip = '172.25.200.15'; info = getIpInfo(ip); portions = getIpPortions(ip, info.defaultMask); if (!portions) throw new Error("Fallback IP falló"); } const question = { key: 'question_identify_host_portion', replacements: { ip: `<strong>${ip}</strong>`, mask: `<strong>${info.defaultMask}</strong>` } }; const correctAnswer = portions.hostPortion || getTranslation('option_none'); let options = new Set([correctAnswer]); if (portions.networkPortion && portions.networkPortion !== correctAnswer) { options.add(portions.networkPortion || getTranslation('option_none')); } let randomIpForPortion, randomInfoForPortion, incorrectHostPortion = null, incorrectNetworkPortion = null, portionAttempts = 0; do { randomIpForPortion = generateRandomIp(); randomInfoForPortion = getIpInfo(randomIpForPortion); if (randomInfoForPortion.defaultMask !== 'N/A') { incorrectHostPortion = getIpPortions(randomIpForPortion, randomInfoForPortion.defaultMask)?.hostPortion; incorrectNetworkPortion = getIpPortions(randomIpForPortion, randomInfoForPortion.defaultMask)?.networkPortion; } portionAttempts++; } while ((!incorrectHostPortion || incorrectHostPortion === correctAnswer) && portionAttempts < 50); if (incorrectHostPortion && incorrectHostPortion !== correctAnswer) { options.add(incorrectHostPortion); } if (incorrectNetworkPortion && incorrectNetworkPortion !== correctAnswer && !options.has(incorrectNetworkPortion)) { options.add(incorrectNetworkPortion || getTranslation('option_none')); } while (options.size < 4) { const randomClass = ['A', 'B', 'C'][getRandomInt(0, 2)]; let randomPortion = ''; if (randomClass === 'A') randomPortion = `${getRandomInt(0, 255)}.${getRandomInt(0, 255)}.${getRandomInt(1, 254)}`; else if (randomClass === 'B') randomPortion = `${getRandomInt(0, 255)}.${getRandomInt(1, 254)}`; else randomPortion = `${getRandomInt(1, 254)}`; if (randomPortion !== correctAnswer) { options.add(randomPortion); } } let optionsArray = Array.from(options); if (!optionsArray.includes(correctAnswer)) { optionsArray.pop(); optionsArray.push(correctAnswer); } optionsArray = optionsArray.slice(0, 4); shuffleArray(optionsArray); const wildcardMask = calculateWildcardMask(info.defaultMask); const networkAddr = calculateNetworkAddress(ip, info.defaultMask); const broadcastAddr = calculateBroadcastAddress(networkAddr, wildcardMask); const explanationInfo = { generatorName: 'generatePortionExplanationHTML', args: [ip, info.defaultMask, wildcardMask, networkAddr, broadcastAddr] }; return { question, options: optionsArray, correctAnswer, explanation: explanationInfo }; } catch (error) { console.error("Error en generateIdentifyHostPortionQuestion:", error); return null; } }
function generateNetworkBroadcastAddressQuestion() { try { let ip, info, attempts = 0; do { ip = generateRandomIp(); info = getIpInfo(ip); attempts++; } while ((info.class !== 'A' && info.class !== 'B' && info.class !== 'C' || info.typeKey === 'loopback') && attempts < 100); if (attempts >= 100) { ip = '172.18.120.30'; info = getIpInfo(ip); } const mask = info.defaultMask; const networkAddr = calculateNetworkAddress(ip, mask); const wildcardMask = calculateWildcardMask(mask); const broadcastAddr = calculateBroadcastAddress(networkAddr, wildcardMask); if (!networkAddr || !broadcastAddr || !wildcardMask) { throw new Error("Error calculando direcciones de red/broadcast/wildcard"); } const askForNetwork = Math.random() < 0.5; const questionTypeKey = askForNetwork ? "address_type_network" : "address_type_broadcast"; const correctAnswer = askForNetwork ? networkAddr : broadcastAddr; const question = { key: 'question_calculate_address', replacements: { ip: `<strong>${ip}</strong>`, mask: `<strong>${mask}</strong>`, addressType: `<strong>${getTranslation(questionTypeKey)}</strong>` } }; let options = new Set([correctAnswer]); const otherAddress = askForNetwork ? broadcastAddr : networkAddr; if (otherAddress !== correctAnswer) options.add(otherAddress); if (ip !== correctAnswer && !options.has(ip)) options.add(ip); let randomIp2, randomInfo2, randomNetAddr, randomBroadAddr, attempts2 = 0; do { randomIp2 = generateRandomIp(); randomInfo2 = getIpInfo(randomIp2); attempts2++; } while ((randomInfo2.class !== 'A' && randomInfo2.class !== 'B' && randomInfo2.class !== 'C' || randomInfo2.typeKey === 'loopback') && attempts2 < 50); if (randomInfo2.defaultMask !== 'N/A') { randomNetAddr = calculateNetworkAddress(randomIp2, randomInfo2.defaultMask); const randomWildcard = calculateWildcardMask(randomInfo2.defaultMask); if (randomNetAddr && randomWildcard) { randomBroadAddr = calculateBroadcastAddress(randomNetAddr, randomWildcard); if (randomNetAddr && randomNetAddr !== correctAnswer && !options.has(randomNetAddr)) options.add(randomNetAddr); if (randomBroadAddr && randomBroadAddr !== correctAnswer && !options.has(randomBroadAddr)) options.add(randomBroadAddr); } } while (options.size < 4) { let randomOptionIp = generateRandomIp(); if (randomOptionIp !== correctAnswer && !options.has(randomOptionIp)) { options.add(randomOptionIp); } } let optionsArray = Array.from(options); if (!optionsArray.includes(correctAnswer)) { optionsArray.pop(); optionsArray.push(correctAnswer); } optionsArray = optionsArray.slice(0, 4); shuffleArray(optionsArray); const explanationInfo = { generatorName: 'generatePortionExplanationHTML', args: [ip, mask, wildcardMask, networkAddr, broadcastAddr] }; return { question, options: optionsArray, correctAnswer, explanation: explanationInfo }; } catch (error) { console.error("Error en generateNetworkBroadcastAddressQuestion:", error); return null; } }
function generateSpecialAddressQuestion() {
    try {
        // Definir los tipos de direcciones especiales y sus claves
        const specialAddressesData = [
            { ip: '127.0.0.1', typeKey: 'loopback', descriptionKey: 'option_loopback' },
            { ip: `169.254.${getRandomInt(1, 254)}.${getRandomInt(1, 254)}`, typeKey: 'apipa', descriptionKey: 'option_apipa' },
            { ip: '255.255.255.255', typeKey: 'limited_broadcast', descriptionKey: 'option_limited_broadcast' }
        ];
        const specialTypeKeys = specialAddressesData.map(s => s.descriptionKey); // Claves de opción para tipos especiales
        const normalTypeKeys = ['option_public', 'option_private']; // Claves de opción para tipos normales

        // --- 1. Seleccionar el Tipo de IP para la Pregunta ---
        // Decide explícitamente si la IP será Especial, Pública o Privada
        const typeCategory = getRandomInt(1, 3); // 1: Especial, 2: Pública, 3: Privada
        let targetIp = '';
        let ipInfo = {};
        let correctAnswerKey = ''; // La clave de la respuesta correcta (ej: 'option_private')
        let explanationInfo = {}; // Información para generar la explicación
        let attempts = 0;

        if (typeCategory === 1) { // IP Objetivo = Especial
            const chosenSpecial = specialAddressesData[getRandomInt(0, specialAddressesData.length - 1)];
            targetIp = chosenSpecial.ip;
            correctAnswerKey = chosenSpecial.descriptionKey;
            explanationInfo = { generatorName: 'generateSpecialAddressExplanationHTML', args: [chosenSpecial.typeKey] };
        } else if (typeCategory === 3) { // IP Objetivo = Privada
            targetIp = generateRandomPrivateIp(); // Generar una IP privada aleatoria
            correctAnswerKey = 'option_private'; // La respuesta correcta es 'Privada'
            explanationInfo = { generatorName: 'generatePrivateRangeTableHTML', args: [targetIp] }; // Usar tabla RFC1918 para explicar
        } else { // IP Objetivo = Pública (typeCategory === 2)
            // Generar IPs aleatorias hasta encontrar una pública
            do {
                targetIp = generateRandomIp();
                ipInfo = getIpInfo(targetIp);
                attempts++;
            } while (ipInfo.typeKey !== 'public' && attempts < 100);
            // Si falla la generación aleatoria, usar una IP pública conocida
            if (ipInfo.typeKey !== 'public') {
                targetIp = '8.8.8.8'; // Fallback a Google DNS
                ipInfo = getIpInfo(targetIp);
            }
            correctAnswerKey = 'option_public'; // La respuesta correcta es 'Pública'
            explanationInfo = { generatorName: 'generatePrivateRangeTableHTML', args: [targetIp] }; // Usar tabla RFC1918 para explicar (mostrará que no es privada)
        }

        // --- 2. Generar las Opciones de Respuesta ---
        let optionsSet = new Set();
        optionsSet.add(correctAnswerKey); // Siempre incluir la respuesta correcta

        let incorrectPool = []; // Pool de opciones incorrectas posibles
        if (normalTypeKeys.includes(correctAnswerKey)) {
            // Si la correcta es Pública o Privada, las incorrectas son las especiales + la otra normal
            incorrectPool = [...specialTypeKeys];
            const otherNormal = normalTypeKeys.find(k => k !== correctAnswerKey);
            if (otherNormal) optionsSet.add(otherNormal); // Asegurar que la otra (Pública/Privada) esté
        } else {
            // Si la correcta es Especial, las incorrectas son las otras especiales + Pública + Privada
            incorrectPool = [...specialTypeKeys.filter(k => k !== correctAnswerKey), ...normalTypeKeys];
             // Asegurar que Pública y Privada estén como opciones
            optionsSet.add('option_public');
            optionsSet.add('option_private');
        }

        // Rellenar las opciones restantes desde el pool de incorrectas
        shuffleArray(incorrectPool);
        for (const incorrect of incorrectPool) {
            if (optionsSet.size < 4) {
                optionsSet.add(incorrect);
            } else {
                break;
            }
        }
         // Asegurar 4 opciones (poco probable necesitar esto aquí, pero seguro)
         while (optionsSet.size < 4) {
             const allTypes = [...specialTypeKeys, ...normalTypeKeys];
             const missing = allTypes.find(t => !optionsSet.has(t));
             if (missing) optionsSet.add(missing); else break;
         }

        let optionsArray = Array.from(optionsSet).slice(0, 4);
        // Verificar que la correcta esté (por si acaso) y barajar
        if (!optionsArray.includes(correctAnswerKey)) {
             optionsArray.pop(); optionsArray.push(correctAnswerKey);
        }
        shuffleArray(optionsArray);

        // --- 3. Formatear la Pregunta y Retornar ---
        // Por simplicidad, siempre preguntaremos "¿Qué tipo es esta IP?"
        const question = { key: 'question_special_what_type', replacements: { ip: `<strong>${targetIp}</strong>` } };
        return { question, options: optionsArray, correctAnswer: correctAnswerKey, explanation: explanationInfo };

        // Nota: Se eliminó la lógica que preguntaba "¿Cuál de estas IPs es de tipo X?"
        // para simplificar y asegurar que siempre se muestre la IP objetivo.

    } catch (error) {
        console.error("Error en generateSpecialAddressQuestion:", error);
        return null; // Retornar null en caso de error
    }
}

// --- Generadores de Preguntas (Nivel Professional) ---
// (generateClassTypeMaskQuestion, generateWildcardQuestion, generateSubnettingQuestion, generateIdentifyIpTypeQuestion, generateBitsForSubnetsQuestion, generateBitsForHostsQuestion sin cambios)
function generateClassTypeMaskQuestion() { try { let ip, info, attempts = 0; do { ip = generateRandomIp(); info = getIpInfo(ip); attempts++; } while ((info.class !== 'A' && info.class !== 'B' && info.class !== 'C' || info.typeKey === 'loopback') && attempts < 100); if (attempts >= 100) { ip = '198.18.0.1'; info = getIpInfo(ip); } const question = { key: 'question_given_ip_what_class_type_mask', replacements: { ip: `<strong>${ip}</strong>` } }; const correctClass = info.class; const correctTypeKey = info.typeKey; const correctMask = info.defaultMask; const correctAnswerObject = { classKey: `option_class_${correctClass.toLowerCase()}`, typeKey: `option_${correctTypeKey}`, maskValue: correctMask }; let options = []; options.push(correctAnswerObject); const possibleClassesLower = ['a', 'b', 'c'].filter(c => c !== correctClass.toLowerCase()); const possibleTypeKeys = ['option_public', 'option_private'].filter(k => k !== `option_${correctTypeKey}`); const possibleMasks = ['255.0.0.0', '255.255.0.0', '255.255.255.0'].filter(m => m !== correctMask); if (possibleMasks.length > 0) { options.push({ ...correctAnswerObject, maskValue: possibleMasks[0] }); } if (possibleTypeKeys.length > 0) { options.push({ ...correctAnswerObject, typeKey: possibleTypeKeys[0] }); } if (possibleClassesLower.length > 0) { let incorrectMask = '255.255.255.255'; if (possibleClassesLower[0] === 'a') incorrectMask = '255.0.0.0'; else if (possibleClassesLower[0] === 'b') incorrectMask = '255.255.0.0'; else if (possibleClassesLower[0] === 'c') incorrectMask = '255.255.255.0'; options.push({ classKey: `option_class_${possibleClassesLower[0]}`, typeKey: correctAnswerObject.typeKey, maskValue: incorrectMask }); } let existingOptionsStr = new Set(options.map(o => `${o.classKey},${o.typeKey},${o.maskValue}`)); while (options.length < 4 && attempts < 500) { const randomClassKey = `option_class_${['a', 'b', 'c'][getRandomInt(0, 2)]}`; const randomTypeKey = ['option_public', 'option_private'][getRandomInt(0, 1)]; const randomMask = ['255.0.0.0', '255.255.0.0', '255.255.255.0'][getRandomInt(0, 2)]; const potentialOption = { classKey: randomClassKey, typeKey: randomTypeKey, maskValue: randomMask }; const potentialOptionStr = `${potentialOption.classKey},${potentialOption.typeKey},${potentialOption.maskValue}`; if (!existingOptionsStr.has(potentialOptionStr)) { options.push(potentialOption); existingOptionsStr.add(potentialOptionStr); } attempts++; } options = options.slice(0, 4); shuffleArray(options); if (!options.some(o => o.classKey === correctAnswerObject.classKey && o.typeKey === correctAnswerObject.typeKey && o.maskValue === correctAnswerObject.maskValue)) { options.pop(); options.push(correctAnswerObject); shuffleArray(options); } const explanationInfo = { generators: [ { generatorName: 'generateClassRangeTableHTML', args: [correctClass] }, { generatorName: 'generatePrivateRangeTableHTML', args: [ip] } ], separator: '<hr style="margin: 10px 0;">' }; return { question, options, correctAnswer: correctAnswerObject, explanation: explanationInfo }; } catch (error) { console.error("Error en generateClassTypeMaskQuestion:", error); return null; } }
function generateWildcardQuestion() { try { const subnetMask = generateRandomSubnetMask(); const correctAnswer = calculateWildcardMask(subnetMask); if (!correctAnswer) throw new Error("No se pudo calcular la wildcard correcta."); const question = { key: 'question_calculate_wildcard', replacements: { subnetMask: `<strong>${subnetMask}</strong>` } }; let options = new Set([correctAnswer]); let attempts = 0; while (options.size < 4 && attempts < 50) { const randomMask = generateRandomSubnetMask(); if (randomMask !== subnetMask) { const incorrectWildcard = calculateWildcardMask(randomMask); if (incorrectWildcard && incorrectWildcard !== correctAnswer) { options.add(incorrectWildcard); } } if (subnetMask !== correctAnswer && options.size < 4) { options.add(subnetMask); } const defaultMasks = ['255.0.0.0', '255.255.0.0', '255.255.255.0']; const randomDefault = defaultMasks[getRandomInt(0, defaultMasks.length - 1)]; const incorrectDefaultWildcard = calculateWildcardMask(randomDefault); if (incorrectDefaultWildcard && incorrectDefaultWildcard !== correctAnswer && options.size < 4) { options.add(incorrectDefaultWildcard); } attempts++; } const simpleWildcards = ['0.0.0.0', '0.0.0.255', '0.0.255.255', '0.255.255.255']; shuffleArray(simpleWildcards); for(const wc of simpleWildcards) { if (options.size < 4 && wc !== correctAnswer) { options.add(wc); } } let optionsArray = Array.from(options); if (!optionsArray.includes(correctAnswer)) { optionsArray.pop(); optionsArray.push(correctAnswer); } optionsArray = optionsArray.slice(0, 4); shuffleArray(optionsArray); const explanationInfo = { generatorName: 'generateWildcardExplanationHTML', args: [subnetMask, correctAnswer] }; return { question, options: optionsArray, correctAnswer, explanation: explanationInfo }; } catch (error) { console.error("Error en generateWildcardQuestion:", error); return null; } }
function generateSubnettingQuestion() { try { let ip, info, subnetMask, prefixLength, originalClassMask, originalPrefix; let attempts = 0; do { ip = generateRandomIp(); info = getIpInfo(ip); if (info.class !== 'A' && info.class !== 'B' && info.class !== 'C') continue; originalClassMask = info.defaultMask; originalPrefix = getMaskPrefixLength(originalClassMask); subnetMask = generateRandomSubnetMask(); prefixLength = getMaskPrefixLength(subnetMask); if (prefixLength !== null && subnetMask !== originalClassMask && prefixLength > originalPrefix && prefixLength <= 30) { break; } attempts++; } while (attempts < 100); if (attempts >= 100) { ip = '192.168.1.150'; info = getIpInfo(ip); subnetMask = '255.255.255.192'; prefixLength = 26; originalClassMask = '255.255.255.0'; originalPrefix = 24; } const networkAddr = calculateNetworkAddress(ip, subnetMask); const wildcardMask = calculateWildcardMask(subnetMask); const broadcastAddr = calculateBroadcastAddress(networkAddr, wildcardMask); const usableHosts = calculateUsableHosts(subnetMask); const numSubnets = calculateNumberOfSubnets(originalClassMask, subnetMask); if (networkAddr === null || broadcastAddr === null || usableHosts === null || numSubnets === null) { throw new Error(`Error calculando valores de subnetting para ${ip}/${subnetMask}`); } const questionType = getRandomInt(0, 3); let questionKey = ''; let correctAnswer; let options = new Set(); let correctAnswerFormatted; switch (questionType) { case 0: questionKey = 'question_subnetting_calculate_network'; correctAnswer = networkAddr; options.add(correctAnswer); options.add(broadcastAddr); if(ip !== networkAddr) options.add(ip); let randomNetAddr; do { randomNetAddr = calculateNetworkAddress(generateRandomIp(), subnetMask); } while (!randomNetAddr || randomNetAddr === correctAnswer); options.add(randomNetAddr); correctAnswerFormatted = correctAnswer; break; case 1: questionKey = 'question_subnetting_calculate_broadcast'; correctAnswer = broadcastAddr; options.add(correctAnswer); options.add(networkAddr); if(ip !== broadcastAddr) options.add(ip); let randomBroadAddr; do { const tempNet = calculateNetworkAddress(generateRandomIp(), subnetMask); const tempWild = calculateWildcardMask(subnetMask); if(tempNet && tempWild) randomBroadAddr = calculateBroadcastAddress(tempNet, tempWild); } while (!randomBroadAddr || randomBroadAddr === correctAnswer); options.add(randomBroadAddr); correctAnswerFormatted = correctAnswer; break; case 2: questionKey = 'question_subnetting_calculate_usable_hosts'; correctAnswer = usableHosts; options.add(correctAnswer); const hostBits = 32 - prefixLength; if (hostBits >= 2) options.add(Number(BigInt(2) ** BigInt(hostBits))); if (hostBits > 2) options.add(Number(BigInt(2) ** BigInt(hostBits - 1) - BigInt(2))); if (hostBits < 30 && prefixLength > originalPrefix) options.add(Number(BigInt(2) ** BigInt(hostBits + 1) - BigInt(2))); correctAnswerFormatted = formatNumber(correctAnswer); break; case 3: questionKey = 'question_subnetting_calculate_num_subnets'; correctAnswer = numSubnets; options.add(correctAnswer); const subnetBits = prefixLength - originalPrefix; if (subnetBits > 0) { const lowerPower = Number(BigInt(2) ** BigInt(subnetBits - 1)); if (lowerPower >= 1 && lowerPower !== correctAnswer) options.add(lowerPower); } const nextSubnetBits = subnetBits + 1; if ((originalPrefix + nextSubnetBits) <= 30) { const higherPower = Number(BigInt(2) ** BigInt(nextSubnetBits)); if (higherPower !== correctAnswer) options.add(higherPower); } if (subnetBits > 0 && subnetBits !== correctAnswer) options.add(subnetBits); if (prefixLength !== correctAnswer) options.add(prefixLength); correctAnswerFormatted = formatNumber(correctAnswer); break; } let fillAttempts = 0; while(options.size < 4 && fillAttempts < 50) { if (questionType <= 1) { let randomIpOption = generateRandomIp(); if (randomIpOption !== correctAnswer && !options.has(randomIpOption)) { options.add(randomIpOption); } } else { let randomNumOption; const base = correctAnswer > 4 ? correctAnswer : 2; const range = Math.max(10, Math.ceil(base / 2)); randomNumOption = getRandomInt(Math.max(1, base - range), base + range); if (correctAnswer !== 0 && randomNumOption === 0) randomNumOption = 1; if (randomNumOption !== correctAnswer && !options.has(randomNumOption)) { options.add(randomNumOption); } } fillAttempts++; } let optionsArray = Array.from(options).map(opt => { return (questionType >= 2) ? formatNumber(opt) : opt.toString(); }); if (!optionsArray.includes(correctAnswerFormatted)) { optionsArray.pop(); optionsArray.push(correctAnswerFormatted); } optionsArray = optionsArray.slice(0, 4); shuffleArray(optionsArray); const question = { key: questionKey, replacements: { ip: `<strong>${ip}</strong>`, mask: `<strong>${subnetMask}</strong>`, prefixLength: prefixLength, class: info.class } }; const explanationInfo = { generatorName: 'generateSubnettingExplanationHTML', args: [ip, subnetMask, networkAddr, broadcastAddr, usableHosts, numSubnets, originalClassMask] }; return { question, options: optionsArray, correctAnswer: correctAnswerFormatted, explanation: explanationInfo }; } catch (error) { console.error("Error en generateSubnettingQuestion:", error); return null; } }
function generateIdentifyIpTypeQuestion() { try { let ip, info, subnetMask, prefixLength, networkAddr, broadcastAddr, firstUsable, lastUsable; let attempts = 0; do { ip = generateRandomIp(); info = getIpInfo(ip); if (info.class !== 'A' && info.class !== 'B' && info.class !== 'C') continue; subnetMask = generateRandomSubnetMask(); prefixLength = getMaskPrefixLength(subnetMask); if (prefixLength !== null && subnetMask !== info.defaultMask && prefixLength <= 30) { networkAddr = calculateNetworkAddress(ip, subnetMask); const wildcardMask = calculateWildcardMask(subnetMask); broadcastAddr = calculateBroadcastAddress(networkAddr, wildcardMask); firstUsable = getFirstUsableHost(networkAddr, subnetMask); lastUsable = getLastUsableHost(broadcastAddr, subnetMask); if (networkAddr && broadcastAddr && firstUsable && lastUsable) { break; } } attempts++; } while (attempts < 100); if (attempts >= 100) { ip = '192.168.1.150'; subnetMask = '255.255.255.192'; prefixLength = 26; networkAddr = '192.168.1.128'; broadcastAddr = '192.168.1.191'; firstUsable = '192.168.1.129'; lastUsable = '192.168.1.190'; } const typeChoice = getRandomInt(0, 2); let targetIp = ''; let correctAnswerKey = ''; let correctIpType = ''; if (typeChoice === 0) { targetIp = networkAddr; correctAnswerKey = 'option_network_address'; correctIpType = 'network'; } else if (typeChoice === 1) { targetIp = broadcastAddr; correctAnswerKey = 'option_broadcast_address'; correctIpType = 'broadcast'; } else { targetIp = (Math.random() < 0.5) ? firstUsable : lastUsable; correctAnswerKey = 'option_usable_host_address'; correctIpType = 'usable'; } const question = { key: 'question_identify_ip_type_in_subnet', replacements: { ip: `<strong>${ip}</strong>`, mask: `<strong>${subnetMask}</strong>`, prefixLength: prefixLength, targetIp: `<strong>${targetIp}</strong>` } }; let options = [ 'option_network_address', 'option_broadcast_address', 'option_usable_host_address' ]; options.push('option_private'); shuffleArray(options); if (!options.includes(correctAnswerKey)) { options.pop(); options.push(correctAnswerKey); shuffleArray(options); } options = options.slice(0, 4); const explanationInfo = { generatorName: 'generateIpTypeExplanationHTML', args: [targetIp, correctIpType, networkAddr, broadcastAddr, prefixLength] }; return { question, options, correctAnswer: correctAnswerKey, explanation: explanationInfo }; } catch (error) { console.error("Error en generateIdentifyIpTypeQuestion:", error); return null; } }
function generateBitsForSubnetsQuestion() { try { const classes = ['A', 'B', 'C']; const chosenClass = classes[getRandomInt(0, classes.length - 1)]; let defaultPrefix; if (chosenClass === 'A') defaultPrefix = 8; else if (chosenClass === 'B') defaultPrefix = 16; else defaultPrefix = 24; let requiredSubnets; let maxPossibleSubnetBits = 30 - defaultPrefix; if (maxPossibleSubnetBits <= 1) return null; const minSubnets = 2; const maxSubnets = Math.pow(2, maxPossibleSubnetBits); requiredSubnets = getRandomInt(minSubnets, Math.min(maxSubnets, 10000)); const subnetBits = Math.ceil(Math.log2(requiredSubnets)); const correctAnswer = subnetBits; let options = new Set([correctAnswer]); if (correctAnswer > 1) options.add(correctAnswer - 1); if ((defaultPrefix + correctAnswer + 1) <= 30) options.add(correctAnswer + 1); options.add(requiredSubnets); options.add(getMaskPrefixLength(generateRandomSubnetMask())); let fillAttempts = 0; while(options.size < 4 && fillAttempts < 50) { let randomNumOption = getRandomInt(Math.max(1, correctAnswer - 3), correctAnswer + 3); if (randomNumOption !== correctAnswer && !options.has(randomNumOption) && randomNumOption > 0) { options.add(randomNumOption); } fillAttempts++; } let optionsArray = Array.from(options).map(opt => opt.toString()); if (!optionsArray.includes(correctAnswer.toString())) { optionsArray.pop(); optionsArray.push(correctAnswer.toString()); } optionsArray = optionsArray.slice(0, 4); shuffleArray(optionsArray); const question = { key: 'question_bits_for_subnets', replacements: { class: chosenClass, defaultPrefix: defaultPrefix, requiredSubnets: formatNumber(requiredSubnets) } }; const resultingSubnets = Number(BigInt(2) ** BigInt(subnetBits)); const explanationInfo = { generatorName: 'generateBitsForSubnetsExplanationHTML', args: [requiredSubnets, subnetBits, resultingSubnets] }; return { question, options: optionsArray, correctAnswer: correctAnswer.toString(), explanation: explanationInfo }; } catch (error) { console.error("Error en generateBitsForSubnetsQuestion:", error); return null; } }
function generateBitsForHostsQuestion() { try { const minHostBitsNeeded = 2; const maxHostBitsPossible = 16; const requiredHosts = getRandomInt(2, Math.pow(2, maxHostBitsPossible) - 2); const hostBits = Math.ceil(Math.log2(requiredHosts + 2)); const correctAnswer = hostBits; let options = new Set([correctAnswer]); if (correctAnswer > 2) options.add(correctAnswer - 1); if (correctAnswer < 30) options.add(correctAnswer + 1); options.add(requiredHosts); const commonNetBits = [8, 16, 24]; options.add(commonNetBits[getRandomInt(0, commonNetBits.length - 1)]); let fillAttempts = 0; while(options.size < 4 && fillAttempts < 50) { let randomNumOption = getRandomInt(Math.max(2, correctAnswer - 3), correctAnswer + 3); if (randomNumOption !== correctAnswer && !options.has(randomNumOption)) { options.add(randomNumOption); } fillAttempts++; } let optionsArray = Array.from(options).map(opt => opt.toString()); if (!optionsArray.includes(correctAnswer.toString())) { optionsArray.pop(); optionsArray.push(correctAnswer.toString()); } optionsArray = optionsArray.slice(0, 4); shuffleArray(optionsArray); const question = { key: 'question_bits_for_hosts', replacements: { requiredHosts: formatNumber(requiredHosts) } }; const resultingHosts = Number(BigInt(2) ** BigInt(hostBits) - BigInt(2)); const explanationInfo = { generatorName: 'generateBitsForHostsExplanationHTML', args: [requiredHosts, hostBits, resultingHosts] }; return { question, options: optionsArray, correctAnswer: correctAnswer.toString(), explanation: explanationInfo }; } catch (error) { console.error("Error en generateBitsForHostsQuestion:", error); return null; } }
function generateMaskForHostsQuestion() { try { const minHostBitsNeeded = 2; const maxHostBitsPossible = 16; const requiredHosts = getRandomInt(2, Math.pow(2, maxHostBitsPossible) - 2); const hostBits = Math.ceil(Math.log2(requiredHosts + 2)); const prefixLength = 32 - hostBits; if (prefixLength < 0 || prefixLength > 30) { return generateMaskForHostsQuestion(); } const correctAnswer = prefixToMaskString(prefixLength); if (!correctAnswer) throw new Error("No se pudo calcular la máscara correcta."); let options = new Set([correctAnswer]); if (prefixLength < 30) { const maskPlus1 = prefixToMaskString(prefixLength + 1); if (maskPlus1 && maskPlus1 !== correctAnswer) options.add(maskPlus1); } if (prefixLength > 1) { const maskMinus1 = prefixToMaskString(prefixLength - 1); if (maskMinus1 && maskMinus1 !== correctAnswer) options.add(maskMinus1); } const defaultMasks = ['255.0.0.0', '255.255.0.0', '255.255.255.0']; const randomDefault = defaultMasks[getRandomInt(0, defaultMasks.length - 1)]; if (randomDefault !== correctAnswer) options.add(randomDefault); let fillAttempts = 0; while(options.size < 4 && fillAttempts < 50) { const randomMask = generateRandomSubnetMask(); if (randomMask !== correctAnswer && !options.has(randomMask)) { options.add(randomMask); } fillAttempts++; } let optionsArray = Array.from(options); if (!optionsArray.includes(correctAnswer)) { optionsArray.pop(); optionsArray.push(correctAnswer); } optionsArray = optionsArray.slice(0, 4); shuffleArray(optionsArray); const question = { key: 'question_mask_for_hosts', replacements: { requiredHosts: formatNumber(requiredHosts) } }; const explanationInfo = { generatorName: 'generateMaskForHostsExplanationHTML', args: [requiredHosts, hostBits, prefixLength, correctAnswer] }; return { question, options: optionsArray, correctAnswer, explanation: explanationInfo }; } catch (error) { console.error("Error en generateMaskForHostsQuestion:", error); return null; } }


// --- Agrupar Generadores por Nivel ---
const entryQuestionGenerators = [ generateClassQuestion, generateTypeQuestion, generateDefaultMaskQuestion, generateSelectClassQuestion, generateSelectPrivateIpQuestion, generateSelectIpByDefaultMaskQuestion ];
const associateQuestionGenerators = [ generateClassAndTypeQuestion, generateClassAndDefaultMaskQuestion, generateClassAndNetworkPortionQuestion, generateClassAndHostPortionQuestion, generateRfc1918Question, generateSpecialAddressQuestion, generateIdentifyNetworkPortionQuestion, generateIdentifyHostPortionQuestion, generateNetworkBroadcastAddressQuestion ];
const professionalQuestionGenerators = [
    generateClassTypeMaskQuestion,
    generateWildcardQuestion,
    generateSubnettingQuestion,
    generateIdentifyIpTypeQuestion,
    generateBitsForSubnetsQuestion,
    generateBitsForHostsQuestion,
    generateMaskForHostsQuestion
];

// --- Función Principal para Obtener Pregunta ---
export function getNextQuestion(level) {
     let generators = [];
     if (level === 'Entry') { generators = entryQuestionGenerators; }
     else if (level === 'Associate') { generators = associateQuestionGenerators; }
     else if (level === 'Professional') { generators = professionalQuestionGenerators; }
     else { console.error("Nivel desconocido solicitado:", level); return null; }
     if (!generators || generators.length === 0) { console.warn(`No hay generadores de preguntas definidos para el nivel: ${level}`); if (level === 'Professional') { console.warn("Usando preguntas de Associate como fallback para Professional."); generators = associateQuestionGenerators; if (!generators || generators.length === 0) return null; } else { return null; } }
     const randomIndex = getRandomInt(0, generators.length - 1);
     const generatorFunction = generators[randomIndex];
     if (generatorFunction && typeof generatorFunction === 'function') {
         try {
             const questionData = generatorFunction();
             if (questionData && questionData.question && Array.isArray(questionData.options) && questionData.options.length > 0 && questionData.correctAnswer !== undefined && questionData.explanation !== undefined) {
                 return questionData;
             } else { console.error(`El generador ${generatorFunction.name} devolvió datos inválidos o incompletos.`, questionData); return null; }
         } catch (error) { console.error(`Error al ejecutar el generador ${generatorFunction.name}:`, error); return null; }
     } else { console.error(`El generador seleccionado para el nivel ${level} en el índice ${randomIndex} no es una función válida.`); return null; }
}
